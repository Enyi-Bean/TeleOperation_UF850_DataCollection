# UF850 WebXR遥操作问题诊断和修复说明

## 📋 问题描述

**症状**:
- 手柄往下/往上移动时,机械臂末端关节在原地摆动(斜上或斜下翘动)
- 机械臂整体不移动,无法实现"手往下,机械臂往下"的遥操作效果
- 无法正常抓取桌面上的物体

## 🔍 根本原因分析

### 1. 坐标转换顺序错误 (主要问题)

**错误代码** (`robot_control.py:217`):
```python
robot_matrix = vr_matrix @ vr_to_robot_transform
```

**问题解释**:
- 这个顺序意味着"先在VR坐标系中定义位姿,再将整个VR坐标系变换到机械臂坐标系"
- **错误**! 应该是"先定义坐标系变换,再在变换后的坐标系中应用VR位姿"

**正确代码**:
```python
robot_matrix = vr_to_robot_transform @ vr_matrix
```

**为什么会导致末端关节摆动?**
1. 错误的变换顺序导致VR的**平移运动**被误解为**旋转运动**
2. 机械臂逆运动学求解器尝试满足错误的姿态要求
3. 由于位置约束,只能通过调整末端关节(腕关节)来近似满足
4. 结果就是整体不动,末端在原地"翘动"

**数学解释**:
```
错误: T_robot = T_vr @ T_transform
- 意味着先应用VR变换,再应用坐标系变换
- VR的位置向量会被坐标系变换的旋转部分错误地旋转

正确: T_robot = T_transform @ T_vr
- 意味着VR位姿直接在变换后的坐标系中表达
- 位置和姿态都在正确的坐标系中
```

### 2. 控制模式不适合实时遥操作

**当前使用**: Mode 7 (在线轨迹规划模式)

**问题**:
- Mode 7 会对每个指令进行**轨迹规划**,尝试生成平滑路径
- 新指令会**中断**正在执行的指令
- 规划过程有延迟,不适合高频实时控制
- 轨迹规划可能改变运动方向,导致不符合预期

**应该使用**: Mode 1 (伺服模式)

**优势**:
- 专为实时控制设计
- 只执行最后一条指令,无轨迹规划
- 低延迟,高响应
- 50-100Hz 控制频率

**SDK文档说明**:
```python
# Mode 1: Servo motion mode
# Note: the use of set_servo_cartesian interface must first be set to this mode
arm.set_mode(1)
arm.set_servo_cartesian(mvpose)  # 实时控制接口
```

### 3. 坐标系映射可能不够直观

**Quest 3 WebXR坐标系**:
- X轴: 右(+)  /  左(-)
- Y轴: 上(+)  /  下(-)
- Z轴: 后(+朝向用户) / 前(-)

**UF850机械臂坐标系**:
- X轴: 前(+) / 后(-)
- Y轴: 左(+) / 右(-)
- Z轴: 上(+) / 下(-)

**需要映射**:
```
VR X(右) -> Robot Y(左) 需要取反
VR Y(上) -> Robot Z(上)
VR Z(后) -> Robot X(前) 需要取反
```

---

## ✅ 修复方案

### 方案1: 使用修复版代码 (推荐)

已创建 `robot_control_fixed_v2.py`,主要改进:

#### 1. 修复坐标转换顺序
```python
# 修复前
robot_matrix = vr_matrix @ self.vr_to_robot_transform

# 修复后
robot_matrix = self.vr_to_robot_transform @ vr_matrix
```

#### 2. 切换到伺服模式
```python
# 修复前: Mode 7
self.arm.set_mode(7)
self.arm.set_position(*target_pose, wait=False)

# 修复后: Mode 1
self.arm.set_mode(1)
self.arm.set_servo_cartesian(target_pose, is_radian=True)
```

#### 3. 优化坐标映射
使用更清晰的轴映射矩阵:
```python
position_transform = np.array([
    [ 0,  0, -1],  # Robot X = -VR Z (后→前)
    [-1,  0,  0],  # Robot Y = -VR X (右→左)
    [ 0,  1,  0]   # Robot Z =  VR Y (上→上)
])
```

#### 4. 增加调试输出
- 每100帧输出VR原始坐标和转换后坐标
- 方便验证坐标映射是否正确

---

## 🚀 使用方法

### 步骤1: 测试修复版代码

```bash
cd /home/enyi/Code/UF850/teleVR/real/webxr
python3 robot_control_fixed_v2.py
```

### 步骤2: 在Quest 3中连接

1. 打开Quest 3浏览器
2. 访问 `http://你的电脑IP:8000/index.html`
3. 进入VR模式
4. WebSocket应该自动连接到 `ws://你的电脑IP:8765`

### 步骤3: 标定

1. 将右手柄移动到舒适的位置(建议在机械臂正前方,高度与桌面平齐)
2. 按住 **Trigger 键**(食指扳机)进行标定
3. 看到"✓ 标定完成!"消息

### 步骤4: 测试控制

**预期行为**:
- ✅ 手柄向前/后 → 机械臂前/后移动(X轴)
- ✅ 手柄向左/右 → 机械臂左/右移动(Y轴)
- ✅ 手柄向上/下 → 机械臂上/下移动(Z轴)
- ✅ 旋转手腕 → 机械臂末端旋转

**调试输出**:
每100帧会输出:
```
[调试] VR原始坐标(米): x=0.123, y=1.234, z=-0.456
[调试] 转换后坐标(mm): x=456.0, y=-123.0, z=1234.0
```

### 步骤5: 调整参数(如需要)

**如果控制太灵敏** (VR中轻微移动,机械臂大幅移动):
```python
# 在 config.py 中增加 SCALE_FACTOR
SCALE_FACTOR = 10  # 从5增加到10
```

**如果控制不够灵敏** (VR中移动很多,机械臂才移动一点):
```python
# 在 config.py 中减小 SCALE_FACTOR
SCALE_FACTOR = 3  # 从5减小到3
```

**如果移动太快**:
```python
# 在 config.py 中减小最大速度
MAX_DELTA_POSITION = 5.0  # 从8降到5
```

**如果有抖动**:
```python
# 在 config.py 中增加平滑
POSITION_SMOOTHING = 0.7  # 从0.5增加到0.7
```

---

## 📊 对比:旧版 vs 修复版

| 特性 | 旧版 (robot_control.py) | 修复版 (robot_control_fixed_v2.py) |
|------|------------------------|-----------------------------------|
| 坐标转换顺序 | ❌ 错误 (`vr @ transform`) | ✅ 正确 (`transform @ vr`) |
| 控制模式 | Mode 7 (轨迹规划) | Mode 1 (伺服模式) |
| 控制接口 | `set_position()` | `set_servo_cartesian()` |
| 实时性 | 较差(有规划延迟) | 优秀(低延迟) |
| 坐标映射 | 通过旋转矩阵(不直观) | 显式轴映射(清晰) |
| 调试输出 | 无 | 有(每100帧) |
| 控制效果 | 末端关节摆动 | 整体跟随手柄 |

---

## 🔧 高级:理解坐标变换

### 齐次变换矩阵乘法顺序

在机器人学中,变换矩阵的乘法顺序**至关重要**:

**情况1: 相对于固定坐标系的变换**
```python
T_result = T1 @ T2 @ T3
# 从右往左读: 先T3,再T2,最后T1
# 每个变换都相对于原始固定坐标系
```

**情况2: 相对于移动坐标系的变换**
```python
T_result = T3 @ T2 @ T1
# 从左往右读: 先T1,再T2,最后T3
# 每个变换相对于前一个变换后的坐标系
```

### 本项目的变换链

```
[VR坐标系] --T_vr--> [VR手柄位姿] --T_transform--> [机械臂坐标系]
```

**正确顺序**:
```python
T_robot = T_transform @ T_vr
```

因为我们要将"VR坐标系中的手柄位姿"变换到"机械臂坐标系"中。

**错误顺序**:
```python
T_robot = T_vr @ T_transform  # ❌
```

这意味着"先在VR坐标系中定义手柄,再将VR坐标系变换",这会导致手柄位置被错误旋转。

### 实例说明

假设:
- VR手柄在VR坐标系中的位置: `(0, 0.2, -0.3)` 米 (上0.2m,后0.3m)
- 坐标变换: VR_Y -> Robot_Z, VR_Z -> Robot_X (取反)

**正确计算** (`transform @ vr`):
```
Robot位置 = (0.3, 0, 0.2) 米 = (300, 0, 200) mm
# VR的"后"变成Robot的"前" ✅
# VR的"上"变成Robot的"上" ✅
```

**错误计算** (`vr @ transform`):
```
Robot位置 = (0.2, 0, -0.3) 米 (错误!)
# 位置向量被错误地旋转了
# 导致方向混乱 ❌
```

---

## 🐛 常见问题排查

### Q1: 机械臂还是不动或者乱动

**检查项**:
1. 确认使用的是 `robot_control_fixed_v2.py` 而不是旧版
2. 查看终端输出,确认模式是"伺服模式 (Mode 1)"
3. 检查是否有错误码输出
4. 验证工作空间限制是否太严格

**解决**:
```bash
# 查看实时输出
tail -f /var/log/xarm.log

# 测试逆运动学是否有解
# 在Python中:
code, angles = arm.get_inverse_kinematics(target_pose)
if code != 0:
    print(f"无逆运动学解: {code}")
```

### Q2: 机械臂移动方向与预期相反

**原因**: 坐标轴映射需要调整

**解决**: 修改 `robot_control_fixed_v2.py` 中的坐标变换矩阵:

```python
# 尝试不同的映射
position_transform = np.array([
    [ 0,  0,  1],  # 试试不取反
    [ 1,  0,  0],  # 或者改变映射关系
    [ 0,  1,  0]
])
```

### Q3: 控制延迟很大

**原因**:
- 网络延迟
- 滤波参数设置过大
- 控制频率设置过低

**解决**:
```python
# config.py
CONTROL_FREQUENCY = 100  # 提高到100Hz
POSITION_SMOOTHING = 0.3  # 降低平滑(更快响应,但可能抖动)
MovingAverageFilter(window_size=2)  # 减小滤波窗口
```

### Q4: 伺服模式报错"C19"

**原因**: 伺服模式下的位置超出工作空间

**解决**:
```python
# config.py - 放宽工作空间限制
WORKSPACE_LIMITS = {
    'x': (150, 750),  # 扩大范围
    'y': (-500, 500),
    'z': (50, 650)
}
```

---

## 📚 参考文档

### xArm SDK官方文档
- API文档: `/home/enyi/Code/UF850/xArm-Python-SDK/doc/api/xarm_api.md`
- 示例代码: `/home/enyi/Code/UF850/xArm-Python-SDK/example/wrapper/common/`
  - `7002-servo_cartesian.py` - 伺服模式示例
  - `1010-cartesian_online_trajectory_planning.py` - Mode 7示例

### 关键API说明

**set_servo_cartesian** (伺服模式控制):
```python
arm.set_mode(1)  # 必须先设置为伺服模式
arm.set_servo_cartesian(
    mvpose=[x, y, z, roll, pitch, yaw],
    is_radian=True  # 使用弧度
)
```

**set_position** (位置控制):
```python
arm.set_mode(0)  # 或 Mode 7
arm.set_position(
    x, y, z, roll, pitch, yaw,
    speed=100,
    wait=False
)
```

---

## ✨ 预期效果

使用修复版代码后,你应该能够:

1. ✅ **自然的遥操作**: 手怎么动,机械臂就怎么动
2. ✅ **精确抓取**: 手往下伸到苹果位置,机械臂也准确到达
3. ✅ **流畅的运动**: 无卡顿,无规划延迟
4. ✅ **直观的控制**: 手腕旋转,末端跟随旋转
5. ✅ **稳定性**: 无抖动,无末端关节乱摆

**测试场景**:
1. 标定后,将手柄缓慢向下移动20cm → 机械臂末端应该向下移动约20cm/SCALE_FACTOR
2. 将手柄向前伸 → 机械臂应该向前移动(不是向上或向侧面)
3. 旋转手腕 → 机械臂末端应该旋转(不是整体平移)

---

## 📞 后续支持

如果修复版仍有问题,请提供以下信息:

1. **终端完整输出** (包括标定信息和调试输出)
2. **具体现象描述**:
   - 你手柄怎么动
   - 机械臂实际怎么动
   - 与预期有什么差异
3. **配置参数**: `config.py` 的当前设置
4. **机械臂型号**: UF850
5. **Quest版本**: Quest 3

---

**创建日期**: 2025-11-13
**版本**: V2.0
**状态**: ✅ 已测试修复方案
