<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3 æ‰‹æŸ„è¯»å– (USB)</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .badge {
            display: inline-block;
            background: #27ae60;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.8em;
            margin-bottom: 20px;
        }

        #status {
            margin: 20px 0;
            padding: 15px 30px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.2em;
        }

        .disconnected { background-color: #e74c3c; }
        .connected { background-color: #27ae60; }
        .connecting { background-color: #f39c12; }

        #startButton {
            padding: 20px 50px;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            margin-top: 20px;
        }

        #startButton:hover {
            transform: translateY(-2px);
        }

        #startButton:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .info {
            margin-top: 20px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        #log {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.8em;
            text-align: left;
        }

        canvas {
            display: none; /* éšè— canvas,åªç”¨äº WebGL */
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1>ğŸ® Quest 3 æ‰‹æŸ„è¯»å–</h1>
        <div class="badge">USB æ¨¡å¼</div>
        <div id="status" class="disconnected">æœªè¿æ¥</div>
        <button id="startButton">å¼€å§‹ VR æ¨¡å¼</button>
        <div class="info">
            <p>âœ“ USB è¿æ¥ - æ— éœ€ WiFi</p>
            <p>ç‚¹å‡»æŒ‰é’®å,æˆ´ä¸Šå¤´æ˜¾è¿›å…¥ VR</p>
            <p>æ‰‹æŸ„æ•°æ®å°†å®æ—¶å‘é€åˆ°æœåŠ¡å™¨</p>
        </div>
        <div id="log"></div>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        const statusDiv = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const logDiv = document.getElementById('log');
        const canvas = document.getElementById('glcanvas');

        let ws = null;
        let gl = null;
        let xrSession = null;
        let xrRefSpace = null;

        // æ—¥å¿—
        function log(message) {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `[${time}] ${message}<br>` + logDiv.innerHTML;
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(status, className) {
            statusDiv.textContent = status;
            statusDiv.className = className;
        }

        // åˆå§‹åŒ– WebGL (å»¶è¿Ÿåˆ° VR ä¼šè¯å¯åŠ¨æ—¶)

        // è¿æ¥ WebSocket
        async function connectWebSocket() {
            return new Promise((resolve, reject) => {
                updateStatus('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', 'connecting');
                log('è¿æ¥åˆ° WebSocket æœåŠ¡å™¨...');

                ws = new WebSocket('ws://localhost:8765');

                ws.onopen = () => {
                    updateStatus('å·²è¿æ¥æœåŠ¡å™¨ (USB)', 'connected');
                    log('âœ“ WebSocket è¿æ¥æˆåŠŸ!');
                    resolve();
                };

                ws.onerror = (error) => {
                    updateStatus('è¿æ¥å¤±è´¥', 'disconnected');
                    log('âœ— è¿æ¥é”™è¯¯,è¯·ç¡®ä¿æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ');
                    reject(error);
                };

                ws.onclose = () => {
                    updateStatus('è¿æ¥æ–­å¼€', 'disconnected');
                    log('WebSocket è¿æ¥å·²å…³é—­');
                };
            });
        }

        // å‘é€æ‰‹æŸ„æ•°æ®
        function sendControllerData(frame) {
            if (!ws || ws.readyState !== WebSocket.OPEN || !xrSession || !xrRefSpace) {
                return;
            }

            const data = {
                timestamp: Date.now(),
                left: null,
                right: null
            };

            // è¯»å–æ‰‹æŸ„æ•°æ®
            for (const source of xrSession.inputSources) {
                if (source.gripSpace) {
                    const gripPose = frame.getPose(source.gripSpace, xrRefSpace);

                    if (gripPose) {
                        const pos = gripPose.transform.position;
                        const ori = gripPose.transform.orientation;

                        const controllerData = {
                            position: { x: pos.x, y: pos.y, z: pos.z },
                            orientation: { x: ori.x, y: ori.y, z: ori.z, w: ori.w },
                            buttons: []
                        };

                        // æŒ‰é’®çŠ¶æ€
                        if (source.gamepad) {
                            controllerData.buttons = source.gamepad.buttons.map(button => ({
                                pressed: button.pressed,
                                touched: button.touched,
                                value: button.value
                            }));

                            // æ‘‡æ†
                            if (source.gamepad.axes.length > 0) {
                                controllerData.axes = Array.from(source.gamepad.axes);
                            }
                        }

                        // å­˜å‚¨åˆ°å¯¹åº”æ‰‹æŸ„
                        if (source.handedness === 'left') {
                            data.left = controllerData;
                        } else if (source.handedness === 'right') {
                            data.right = controllerData;
                        }
                    }
                }
            }

            // å‘é€æ•°æ®
            if (data.left || data.right) {
                try {
                    ws.send(JSON.stringify(data));
                } catch (error) {
                    console.error('å‘é€æ•°æ®å¤±è´¥:', error);
                }
            }
        }

        // VR æ¸²æŸ“å¾ªç¯
        function onXRFrame(time, frame) {
            // æ¸…ç©ºå±å¹•(å¿…é¡»,å¦åˆ™ä¸ä¼šè§¦å‘ä¸‹ä¸€å¸§)
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // å‘é€æ‰‹æŸ„æ•°æ®
            sendControllerData(frame);

            // è¯·æ±‚ä¸‹ä¸€å¸§
            xrSession.requestAnimationFrame(onXRFrame);
        }

        // å¼€å§‹ VR ä¼šè¯
        async function startVRSession() {
            try {
                // æ£€æŸ¥ WebXR æ”¯æŒ
                if (!navigator.xr) {
                    alert('æ­¤æµè§ˆå™¨ä¸æ”¯æŒ WebXR!');
                    log('âœ— æµè§ˆå™¨ä¸æ”¯æŒ WebXR');
                    return;
                }

                const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
                if (!isSupported) {
                    alert('æ­¤è®¾å¤‡ä¸æ”¯æŒ VR!');
                    log('âœ— è®¾å¤‡ä¸æ”¯æŒ VR');
                    return;
                }

                log('æ­£åœ¨å¯åŠ¨ VR ä¼šè¯...');
                startButton.disabled = true;
                startButton.textContent = 'æ­£åœ¨å¯åŠ¨...';

                // åˆå§‹åŒ– WebGL ä¸Šä¸‹æ–‡ï¼ˆå¿…é¡»åœ¨ VR ä¼šè¯ä¹‹å‰ï¼‰
                if (!gl) {
                    try {
                        gl = canvas.getContext('webgl2', { xrCompatible: true });
                        if (!gl) {
                            gl = canvas.getContext('webgl', { xrCompatible: true });
                        }
                        if (!gl) {
                            throw new Error('æ— æ³•åˆ›å»º WebGL ä¸Šä¸‹æ–‡');
                        }
                        log('âœ“ WebGL ä¸Šä¸‹æ–‡å·²åˆ›å»º (XR å…¼å®¹)');
                    } catch (e) {
                        alert('WebGL åˆå§‹åŒ–å¤±è´¥: ' + e.message);
                        log('âœ— WebGL åˆå§‹åŒ–å¤±è´¥: ' + e.message);
                        startButton.disabled = false;
                        startButton.textContent = 'å¼€å§‹ VR æ¨¡å¼';
                        return;
                    }
                }

                // ç¡®ä¿ WebGL ä¸Šä¸‹æ–‡ä¸º XR å…¼å®¹
                await gl.makeXRCompatible();
                log('âœ“ WebGL å·²è®¾ç½®ä¸º XR å…¼å®¹æ¨¡å¼');

                // è¿æ¥ WebSocket
                await connectWebSocket();

                // è¯·æ±‚ VR ä¼šè¯
                try {
                    xrSession = await navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor']
                    });
                } catch (e) {
                    // å¦‚æœå¤±è´¥ï¼Œå°è¯•ä¸å¸¦ç‰¹æ€§çš„ä¼šè¯
                    xrSession = await navigator.xr.requestSession('immersive-vr');
                }
                log('âœ“ VR ä¼šè¯å·²å¯åŠ¨!');

                // åˆ›å»º WebGL å±‚(å…³é”®!)
                const glLayer = new XRWebGLLayer(xrSession, gl);
                await xrSession.updateRenderState({ baseLayer: glLayer });
                log('âœ“ WebGL æ¸²æŸ“å±‚å·²åˆ›å»º');

                // è·å–å‚è€ƒç©ºé—´
                try {
                    xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
                    log('âœ“ ä½¿ç”¨ local-floor å‚è€ƒç©ºé—´');
                } catch (e) {
                    try {
                        xrRefSpace = await xrSession.requestReferenceSpace('local');
                        log('âœ“ ä½¿ç”¨ local å‚è€ƒç©ºé—´');
                    } catch (e2) {
                        xrRefSpace = await xrSession.requestReferenceSpace('viewer');
                        log('âœ“ ä½¿ç”¨ viewer å‚è€ƒç©ºé—´');
                    }
                }

                startButton.textContent = 'VR è¿è¡Œä¸­...';

                // ä¼šè¯ç»“æŸå¤„ç†
                xrSession.addEventListener('end', () => {
                    log('VR ä¼šè¯å·²ç»“æŸ');
                    xrSession = null;
                    startButton.disabled = false;
                    startButton.textContent = 'å¼€å§‹ VR æ¨¡å¼';
                    if (ws) {
                        ws.close();
                    }
                });

                // å¼€å§‹æ¸²æŸ“å¾ªç¯
                xrSession.requestAnimationFrame(onXRFrame);
                log('âœ“ å¼€å§‹è¯»å–æ‰‹æŸ„æ•°æ®...');

            } catch (error) {
                console.error('å¯åŠ¨ VR å¤±è´¥:', error);
                log('âœ— é”™è¯¯: ' + error.message);
                alert('å¯åŠ¨ VR å¤±è´¥: ' + error.message);
                startButton.disabled = false;
                startButton.textContent = 'å¼€å§‹ VR æ¨¡å¼';
            }
        }

        // ç»‘å®šæŒ‰é’®
        startButton.addEventListener('click', startVRSession);

        // é¡µé¢åŠ è½½å®Œæˆ
        log('é¡µé¢å·²åŠ è½½ (USB æ¨¡å¼)');
        log('WebSocket åœ°å€: localhost:8765');
    </script>
</body>
</html>
